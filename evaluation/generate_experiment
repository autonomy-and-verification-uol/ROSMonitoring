#!/usr/bin/env python

import sys
import os
import random
import argparse

def generate_launch_file(n_monitors, topics_for_node):
    text = '''<launch>'''
    for (node, topics_to_pub, topics_to_sub) in topics_for_node:
        text += '''
    <node pkg="beginner_tutorials" type="{name}.py" name="{name}" output="screen">'''.format(name = node)
        if n_monitors != 0:
            for pub in topics_to_pub:
                text += '''
                <remap from="{tp}" to="{tp}_mon"/>'''.format(tp = pub)
        text += '''
    </node>'''
    for i in range(n_monitors):
        text += '''
    <node pkg="monitor" type="monitor_{id}.py" name="monitor_{id}" output="screen"/>'''.format(id = i)
    text +='''
</launch>
    '''
    with open('/home/angelo/catkin_ws1/src/beginner_tutorials/run.launch', 'w') as file:
        file.write(text)

def generate_node(name, topics_to_pub, topics_to_sub, target):
    text = '''#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2019] [Angelo Ferrando]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import rospy
from std_msgs.msg import Float64
from threading import *
import time
from monitor.msg import *
from beginner_tutorials.srv import *

my_lock = Lock()
count = 0
count_error = 0
avg_latency = None
avg_latency_error = None

def callback(data):
    global count
    global avg_latency
    with my_lock:
        count += 1
        if avg_latency:
            avg_latency = (rospy.get_time() - data.data + avg_latency) / count
        else:
            avg_latency = rospy.get_time() - data.data

def callback_error(data):
    global count_error
    global avg_latency_error
    with my_lock:
        count_error += 1
        if avg_latency_error:
            avg_latency_error = (rospy.get_time() - data.time + avg_latency_error) / count_error
        else:
            avg_latency_error = rospy.get_time() - data.time


def node():
    global start_time, count
    rospy.init_node('{node}', anonymous=True)
    '''.format(node = name, tg = target)
    for topic_to_pub in topics_to_pub:
        text +='''
    pub_{tp} = rospy.Publisher(name = '{tp}', data_class = Float64, queue_size=1000, latch = True)'''.format(tp = topic_to_pub)
    text += '''
    rospy.Subscriber('monitor_error', MonitorError, callback_error)
    send_time = rospy.ServiceProxy('send_time', SendTime)'''
    for topic_to_sub in topics_to_sub:
        text +='''
    rospy.Subscriber('{tp}', Float64, callback)'''.format(tp = topic_to_sub)
    text +='''
    rate = rospy.Rate(1000)
    rospy.sleep(5)
    start_time = rospy.get_time()
    sent = False
    while not rospy.is_shutdown():
        if count >= {tg} and not sent:
            send_time((rospy.get_time() - start_time), avg_latency, avg_latency_error)
            sent = True
        custom_msg = rospy.get_time()'''.format(tg = target)
    for topic_to_pub in topics_to_pub:
        text +='''
        pub_{tp}.publish(custom_msg)
        '''.format(tp = topic_to_pub)
    text += '''
        rate.sleep()
    #with open('log.txt', 'a+') as log_file:
    #    log_file.write('{node} finished in: ' + str((rospy.get_time() - start_time)) + '\\n')
    #    log_file.write('{node} avg latency: ' + str(avg_latency) + '\\n')
    #    log_file.write('{node} avg latency error: ' + str(avg_latency_error) + '\\n')
    #rospy.loginfo('{node} finished in: ' + str((rospy.get_time() - start_time)))
    #rospy.loginfo('{node} avg latency: ' + str(avg_latency))
if __name__ == '__main__':
    try:
        node()
    except rospy.ROSInterruptException:
        pass
    '''.format(node = name)
    with open('/home/angelo/catkin_ws1/src/beginner_tutorials/scripts/' + name + '.py', 'w') as file:
        file.write(text)
    os.system('chmod +x /home/angelo/catkin_ws1/src/beginner_tutorials/scripts/' + name + '.py')

def generate_nodes(n_nodes, n_topics, target):
    topics = {'topic_' + str(i) for i in range(n_topics)}
    topics_for_node = [('node_' + str(i), set(), set()) for i in range(n_nodes)]
    j = 0
    for i in range(n_topics):
        topics_for_node[j][1].add('topic_' + str(i))
        j = (j + 1) % n_nodes
    for (node, topics_to_pub, topics_to_sub) in topics_for_node:
        topics_to_sub.update(topics.difference(topics_to_pub))
    for (node, topics_to_pub, topics_to_sub) in topics_for_node:
        generate_node(node, topics_to_pub, topics_to_sub, target)
    return topics_for_node

def generate_monitors_yaml_file(n_monitors, topics_for_node):
    text = '''
# MIT License
#
# Copyright (c) [2019] [Angelo Ferrando]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Config file for the instrumentation of ROS
# this file is given in input to generator
#
nodes:'''
    for (node, _, _) in topics_for_node:
        text += '''
    - node:
        name: {n}
        package: beginner_tutorials
        path: /home/angelo/catkin_ws1/src/beginner_tutorials/run.launch'''.format(n = node)
    text += '''
monitors:'''
    topics_for_monitor = [('monitor_'+str(i), []) for i in range(n_monitors)]
    j = 0
    for (node, topics_to_pub, topics_to_sub) in topics_for_node:
        topics_for_monitor[j][1].append((node, topics_to_pub))
        j = (j + 1) % n_monitors
    port = 8080
    for (monitor, topics_nodes) in topics_for_monitor:
        text += '''
    - monitor:
        id: {id}
        log: ./log_{id}.txt # file where the monitor will log the observed events
        silent: True
        oracle: # the oracle running and ready to check the specification
            port: {p} # the port where it is listening
            url: 127.0.0.1 # the url where it is listening
            action: nothing
        topics:'''.format(id = monitor, p = port)
        port += 1
        for (node, topics) in topics_nodes:
            for topic in topics:
                text +='''
            - name: {tp}
              type: std_msgs.msg.Float64
              action: log
              warning: True
              publishers:'''.format(tp = topic)
            text += '''
                - {n}'''.format(n = node)
    with open('../generator/config_eval.yaml', 'w') as file:
        file.write(text)

def generate_experiment(n_nodes, n_topics, n_monitors, target):
    topics_for_node = generate_nodes(n_nodes, n_topics, target)
    if n_monitors != 0:
        generate_monitors_yaml_file(n_monitors, topics_for_node)
    generate_launch_file(n_monitors, topics_for_node)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='this is a Python program to generate a test experiment for evaluating the delays produced by ROSMon',
        formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('--n_nodes',
        help='Number of nodes to use in the experiment',
        default = '10',
        type=int)
    parser.add_argument('--n_topics',
        help='Number of topics published in total by the nodes (distributed randomly on the nodes created)',
        default = '10',
        type=int)
    parser.add_argument('--n_monitors',
        help='Number of monitors for monitoring the nodes',
        default = '1',
        type=int)
    parser.add_argument('--target',
        help='Target number of times the topics have to be received',
        default = '1000',
        type=int)
    args = parser.parse_args()
    generate_experiment(args.n_nodes, args.n_topics, args.n_monitors, args.target)
    # n = int(sys.argv[1])
    # np = int(sys.argv[2])
    # for i in range(n):
    #     create_talker(i, np)
    #     create_listener(i, np)
    #     os.system('chmod +x ../../rosmon/scripts/talker_' + str(i) + '.py')
    #     os.system('chmod +x ../../rosmon/scripts/listener_' + str(i) + '.py')
    # create_launch_file(n)
